'''
尽量减少恶意软件的传播
在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。

一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。
这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。

假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。

我们可以从初始列表中删除一个节点。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。

请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后可能仍然因恶意软件传播而受到感染。

 

示例 1：

输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
输出：0
示例 2：

输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
输出：0
示例 3：

输入：graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
输出：1
 

提示：

1 < graph.length = graph[0].length <= 300
0 <= graph[i][j] == graph[j][i] <= 1
graph[i][i] == 1
1 <= initial.length < graph.length
0 <= initial[i] < graph.length
'''
from typing import List
'''
思路：并查集
1、遍历矩阵并加入并查集
2、遍历所有节点i，0<=i<n
    如果i在initial中：
        如果i==rootid，忽略
        如果i!=rootid，将rootid加入set:sickRoots
    如果i不在initial中：
        如果i==rootid，忽略
        如果i!=rootid，且rootid在initial中，将rootid加入sickRoots
3、从小到大遍历initial，如果i的rootid在sickRoots中，将其返回
时间复杂度：O(n*n)
空间复杂度：O(n)
'''


# 定义并查集
class UnionFind:
    def __init__(self, n):
        self.n = n
        self.parent = list(range(n))

    def find(self, i):
        if self.parent[i] != i:
            self.parent[i] = self.find(self.parent[i])
        return self.parent[i]

    def unite(self, i, j):
        rooti = self.find(i)
        rootj = self.find(j)
        if rooti != rootj:
            if rooti > rootj:  # 确保较小的作为根节点
                rooti, rootj = rootj, rooti
                i, j = j, i
            self.parent[rootj] = rooti


class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        # 1、遍历矩阵并加入并查集
        unionFind = UnionFind(n)
        for i in range(n):
            for j in range(i):
                unionFind.unite(j, i)
        initSet = set(initial)
        # 2、遍历节点，符合条件的根节点加入sickRoots
        sickRoots = set()
        for i in range(n):
            rootid = unionFind.find(i)
            if i in initSet:
                if i != rootid:
                    sickRoots.add(rootid)
            else:
                if i != rootid and rootid in sickRoots:
                    sickRoots.add(rootid)
        # 3、找到最小的已感染节点
        for i in initial:
            if unionFind.find(i) in sickRoots:
                return i


s = Solution()
print(s.minMalwareSpread(graph=[[1, 1, 0], [1, 1, 0], [0, 0, 1]], initial=[0, 1]))
print(s.minMalwareSpread(graph=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], initial=[0, 2]))
print(s.minMalwareSpread(graph=[[1, 1, 1], [1, 1, 1], [1, 1, 1]], initial=[1, 2]))
