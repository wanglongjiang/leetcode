'''
629. K个逆序对数组
给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。

逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对；否则不是。

由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。

示例 1:

输入: n = 3, k = 0
输出: 1
解释:
只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。
示例 2:

输入: n = 3, k = 1
输出: 2
解释:
数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。
说明:

 n 的范围是 [1, 1000] 并且 k 的范围是 [0, 1000]。
'''
'''
动态规划
首先，1~n 这 n 个数所能产生的最大逆序对为 n * (n - 1) / 2 对。
　　设 dp[i][j] 表示 1~i 能产生 j 对逆序对的排列种数。
　　这里定义一下如果下标为负数，这一项为 0。
　　在考虑接下来一个事实：对于序列 1,2,3,4,5 和 2,5,7,9,10，在这个问题下，我可以说这两个序列是等价的，因为产生逆序对的本质是大小关系而不是数实际的大小。
　　现在考虑状态转移方程。
　　首先当 j > i * (i - 1) / 2 时，dp[i][j] = 0。
　　其次当 j = 0 时，dp[i][0] = 1，只有顺着排一种方法。
　　以上确定了初始状态。
　　对于其他 dp[i][j]，我们如果考虑在队头放第 k 大的数，那么这个数就贡献了 k - 1 对逆序对，剩下的 i - 1 个不同的数就可以转化为子问题，也就是 dp[i - 1][j - k]。
　　同理我们也可以在队头放其他数，分别求一下贡献，就能得到状态转移方程：
dp[i][j]=∑k=max(0,j−i+1)jdp[i−1][k]
　　仔细观察前后两项的关系可以发现：
dp[i][j]=dp[i][j−1]+dp[i−1][j]−dp[i−1][max(0,j−i+1)−1]
　　不过不推这个式子也能做，搞个前缀和即可。
'''


class Solution:
    def kInversePairs(self, n: int, k: int) -> int:
        dp = [[0] * (k + 1) for _ in range(2)]
        m = 10**9 + 7
        now = 0
        dp[now][0] = 1
        for i in range(1, n + 1):
            now, other = (0, 1) if now else (1, 0)
            dp[now][0] = 1
            for j in range(1, k + 1):
                if 2 * j > i * (i - 1):
                    break
                dp[now][j] = (dp[now][j - 1] + dp[other][j]) % m
                if j - i >= 0:
                    dp[now][j] = (dp[now][j] - dp[other][j - i] + m) % m
        return dp[now][k]
