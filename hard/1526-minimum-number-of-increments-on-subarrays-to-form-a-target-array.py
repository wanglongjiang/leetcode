'''
1526. 形成目标数组的子数组最少增加次数
给你一个整数数组 target 和一个数组 initial ，initial 数组与 target  数组有同样的维度，且一开始全部为 0 。

请你返回从 initial 得到  target 的最少操作次数，每次操作需遵循以下规则：

在 initial 中选择 任意 子数组，并将子数组中每个元素增加 1 。
答案保证在 32 位有符号整数以内。

 

示例 1：

输入：target = [1,2,3,2,1]
输出：3
解释：我们需要至少 3 次操作从 intial 数组得到 target 数组。
[0,0,0,0,0] 将下标为 0 到 4 的元素（包含二者）加 1 。
[1,1,1,1,1] 将下标为 1 到 3 的元素（包含二者）加 1 。
[1,2,2,2,1] 将下表为 2 的元素增加 1 。
[1,2,3,2,1] 得到了目标数组。
示例 2：

输入：target = [3,1,1,2]
输出：4
解释：(initial)[0,0,0,0] -> [1,1,1,1] -> [1,1,1,2] -> [2,1,1,2] -> [3,1,1,2] (target) 。
示例 3：

输入：target = [3,1,5,4,2]
输出：7
解释：(initial)[0,0,0,0,0] -> [1,1,1,1,1] -> [2,1,1,1,1] -> [3,1,1,1,1] 
                                  -> [3,1,2,2,2] -> [3,1,3,3,2] -> [3,1,4,4,2] -> [3,1,5,4,2] (target)。
示例 4：

输入：target = [1,1,1,1]
输出：1
 

提示：

1 <= target.length <= 10^5
1 <= target[i] <= 10^5
'''

from typing import List
'''
思路：单调栈
将target中的数字看成海拔，整个数组形成了高低起伏的群山。
相邻的山峰a、b需要操作的次数是山峰a到山谷的相对海拔，山峰b到山谷的相对海拔。如果山谷比其他山谷高，它需要操作的次数是它相对其他山谷的海拔。
从上述分析看出，决定一个点的操作次数是其与较低邻居的相对高度，所以这里用单调栈。

设一个单调栈，栈内元素递增。
遍历target数组，
- 如果当前元素target[i]大于栈顶元素，入栈
- 如果小于等于栈顶元素，将栈顶元素出栈，操作次数加上2者的差。重复出栈，直至栈顶元素小于target[i]，然后将其入栈。

时间复杂度：O(n)
空间复杂度：O(n)
'''


class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        ans, stk = 0, []
        for num in target:
            if stk and stk[-1] >= num:
                ans += stk.pop() - num
            while stk and stk[-1] >= num:  # 比原栈顶低的部分，因为栈顶的操作次数已经涵盖了，所以不能重复累计
                stk.pop()
            stk.append(num)
        return ans + stk[-1]


s = Solution()
print(s.minNumberOperations([3, 4, 2, 5, 6]))
