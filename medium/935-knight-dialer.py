'''
935. 骑士拨号器
国际象棋中的骑士可以按下图所示进行移动：



这一次，我们将 “骑士” 放在电话拨号盘的任意数字键（如上图所示）上，接下来，骑士将会跳 N-1 步。每一步必须是从一个数字键跳到另一个数字键。

每当它落在一个键上（包括骑士的初始位置），都会拨出键所对应的数字，总共按下 N 位数字。

你能用这种方式拨出多少个不同的号码？

因为答案可能很大，所以输出答案模 10^9 + 7。



示例 1：

输入：1
输出：10
示例 2：

输入：2
输出：20
示例 3：

输入：3
输出：46


提示：

1 <= N <= 5000
'''
'''
思路：动态规划
从题意中得知，骑士只能跳日字，那么1可以跳6、8，2可以跳7、9，3可以跳4、8，。。。
可以设二维数组dp[n][10]，dp[i][j]的意思是第i步，跳到第j个数字的路径数量，
根据上面的跳转关系，得到状态转移方程：
dp[i][0] = dp[i-1][4]+dp[i-1][6]
dp[i][1] = dp[i-1][8]+dp[i-1][6]
...
最后将dp[n-1]所有路径合计起来即为答案

时间复杂度：O(n)
空间复杂度：O(n)
'''


class Solution:
    def knightDialer(self, n: int) -> int:
        jump = [[4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]]  # 各个位置的跳转关系
        dp = [[0] * 10 for _ in range(n)]
        for i in range(10):  # 初始值为1
            dp[0][i] = 1
        for i in range(1, n):
            for j in range(10):
                dp[i][j] = sum(map(lambda k: dp[i - 1][k], jump[j])) % 1000000007  # 合计所有能跳到j的路径总数
        return sum(dp[n - 1]) % 1000000007


s = Solution()
print(s.knightDialer(1))
print(s.knightDialer(2))
print(s.knightDialer(3))
