'''
1997. 访问完所有房间的第一天
你需要访问 n 个房间，房间从 0 到 n - 1 编号。同时，每一天都有一个日期编号，从 0 开始，依天数递增。你每天都会访问一个房间。

最开始的第 0 天，你访问 0 号房间。给你一个长度为 n 且 下标从 0 开始 的数组 nextVisit 。在接下来的几天中，你访问房间的 次序 将根据下面的 规则 决定：

假设某一天，你访问 i 号房间。
如果算上本次访问，访问 i 号房间的次数为 奇数 ，那么 第二天 需要访问 nextVisit[i] 所指定的房间，其中 0 <= nextVisit[i] <= i 。
如果算上本次访问，访问 i 号房间的次数为 偶数 ，那么 第二天 需要访问 (i + 1) mod n 号房间。
请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 109 + 7 取余后的结果。

 

示例 1：

输入：nextVisit = [0,0]
输出：2
解释：
- 第 0 天，你访问房间 0 。访问 0 号房间的总次数为 1 ，次数为奇数。
  下一天你需要访问房间的编号是 nextVisit[0] = 0
- 第 1 天，你访问房间 0 。访问 0 号房间的总次数为 2 ，次数为偶数。
  下一天你需要访问房间的编号是 (0 + 1) mod 2 = 1
- 第 2 天，你访问房间 1 。这是你第一次完成访问所有房间的那天。
示例 2：

输入：nextVisit = [0,0,2]
输出：6
解释：
你每天访问房间的次序是 [0,0,1,0,0,1,2,...] 。
第 6 天是你访问完所有房间的第一天。
示例 3：

输入：nextVisit = [0,1,2,0]
输出：6
解释：
你每天访问房间的次序是 [0,0,1,1,2,2,3,...] 。
第 6 天是你访问完所有房间的第一天。
 

提示：

n == nextVisit.length
2 <= n <= 10^5
0 <= nextVisit[i] <= i
'''
from typing import List
'''
思路：动态规划
因为nextVisit[i]<=i，也就是访问前面的房间，第i个想要被访问到，肯定是i-1个房间访问了第2次后。
设二维数组dp[n][2]，dp[i][0]是第i个房间第1次访问时的日期，dp[i][1]时第i个房间第2次访问时访问的日期
状态转移方程为：
dp[i][0] = dp[i-1][1]+1，解释：每个房间访问的第1天，肯定是上一个房间第2次访问的日期+1
dp[i][1] = 2*dp[i][0]-dp[nextVisit[i]][0]，解释：每个房间访问的第2天，是第1次访问的日期+第1次访问和第2次访问的间隔天数
从第1次访问到第2次访问，间隔了多少天呢，是dp[i][0]-dp[nextVisit[i]][0]+1，也就是从nextVisit[i]指定的房间开始，又一次访问到了本房间所需要的时间。

时间复杂度：O(n)
空间复杂度：O(n)
'''


class Solution:
    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:
        m = 10**9 + 7
        dp = [[0, 0] for _ in range(len(nextVisit))]
        dp[0] = [0, 1]
        for i in range(1, len(nextVisit)):
            dp[i][0] = (dp[i - 1][1] + 1) % m
            dp[i][1] = (2 * dp[i][0] - dp[nextVisit[i]][0] + 1) % m
        return dp[-1][0]


s = Solution()
print(s.firstDayBeenInAllRooms([0, 0, 2]) == 6)
print(s.firstDayBeenInAllRooms([0, 1, 2, 0]) == 6)
print(s.firstDayBeenInAllRooms([0, 0]))
