'''
将整数按权重排序
我们将整数 x 的 权重 定义为按照下述规则将 x 变成 1 所需要的步数：

如果 x 是偶数，那么 x = x / 2
如果 x 是奇数，那么 x = 3 * x + 1
比方说，x=3 的权重为 7 。因为 3 需要 7 步变成 1 （3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1）。

给你三个整数 lo， hi 和 k 。你的任务是将区间 [lo, hi] 之间的整数按照它们的权重 升序排序 ，如果大于等于 2 个整数有 相同 的权重，
那么按照数字自身的数值 升序排序 。

请你返回区间 [lo, hi] 之间的整数按权重排序后的第 k 个数。

注意，题目保证对于任意整数 x （lo <= x <= hi） ，它变成 1 所需要的步数是一个 32 位有符号整数。

 

示例 1：

输入：lo = 12, hi = 15, k = 2
输出：13
解释：12 的权重为 9（12 --> 6 --> 3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1）
13 的权重为 9
14 的权重为 17
15 的权重为 17
区间内的数按权重排序以后的结果为 [12,13,14,15] 。对于 k = 2 ，答案是第二个整数也就是 13 。
注意，12 和 13 有相同的权重，所以我们按照它们本身升序排序。14 和 15 同理。
示例 2：

输入：lo = 1, hi = 1, k = 1
输出：1
示例 3：

输入：lo = 7, hi = 11, k = 4
输出：7
解释：区间内整数 [7, 8, 9, 10, 11] 对应的权重为 [16, 3, 19, 6, 14] 。
按权重排序后得到的结果为 [8, 10, 11, 7, 9] 。
排序后数组中第 4 个数字为 7 。
示例 4：

输入：lo = 10, hi = 20, k = 5
输出：13
示例 5：

输入：lo = 1, hi = 1000, k = 777
输出：570

提示：
1 <= lo <= hi <= 1000
1 <= k <= hi - lo + 1
'''
'''
思路：递归+记忆化+排序
1. 按照权重的定义用递归计算权重，计算过程中注意使用记忆化
2. 排序找到第k个元素

时间复杂度：O(nlogn)
空间复杂度：O(n)
'''


class Solution:
    def getKth(self, lo: int, hi: int, k: int) -> int:
        mem = {}

        # 计算权重
        def weight(num):
            if num == 1:
                return 0
            if num in mem:
                return mem[num]
            if num & 1:
                w = 1 + weight((num << 1) + num + 1)  # 奇数x = 3 * x + 1
                mem[num] = w
                return w
            else:
                w = 1 + weight(num >> 1)  # 偶数x=x/2
                mem[num] = w
                return w

        weights = [(weight(num), num) for num in range(lo, hi + 1)]
        # 排序找出第k个数
        weights.sort(key=lambda p: (p[0] << 10) + p[1])
        return weights[k - 1][1]


s = Solution()
print(s.getKth(lo=10, hi=20, k=5) == 13)
print(s.getKth(lo=7, hi=11, k=4) == 7)
print(s.getKth(lo=12, hi=15, k=2) == 13)
print(s.getKth(lo=1, hi=1, k=1) == 1)
print(s.getKth(lo=1, hi=1000, k=777) == 570)
