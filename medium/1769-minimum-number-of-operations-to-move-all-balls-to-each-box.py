'''
1769. 移动所有球到每个盒子所需的最小操作数
中等
44
相关企业
有 n 个盒子。给你一个长度为 n 的二进制字符串 boxes ，其中 boxes[i] 的值为 '0' 表示第 i 个盒子是 空 的，而 boxes[i] 的值为 '1' 表示盒子里有 一个 小球。

在一步操作中，你可以将 一个 小球从某个盒子移动到一个与之相邻的盒子中。第 i 个盒子和第 j 个盒子相邻需满足 abs(i - j) == 1 。注意，操作执行后，某些盒子中可能会存在不止一个小球。

返回一个长度为 n 的数组 answer ，其中 answer[i] 是将所有小球移动到第 i 个盒子所需的 最小 操作数。

每个 answer[i] 都需要根据盒子的 初始状态 进行计算。

 

示例 1：

输入：boxes = "110"
输出：[1,1,3]
解释：每个盒子对应的最小操作数如下：
1) 第 1 个盒子：将一个小球从第 2 个盒子移动到第 1 个盒子，需要 1 步操作。
2) 第 2 个盒子：将一个小球从第 1 个盒子移动到第 2 个盒子，需要 1 步操作。
3) 第 3 个盒子：将一个小球从第 1 个盒子移动到第 3 个盒子，需要 2 步操作。将一个小球从第 2 个盒子移动到第 3 个盒子，需要 1 步操作。共计 3 步操作。
示例 2：

输入：boxes = "001011"
输出：[11,8,5,4,3,4]
 

提示：

n == boxes.length
1 <= n <= 2000
boxes[i] 为 '0' 或 '1'
'''
from typing import List
'''
[TOC]

# 思路
动态规划

# 解题方法

首先从左向右遍历boxes，这个过程计算左边的1移动到当前坐标i需要的操作数，

设一个数组dp1[n],dp1[i]的意思是左边的球移动到当前盒子需要的操作数，状态转移方程为：
> dp1[i] = dp1[i-1]+counti，counti是i下标左边的球的个数，意思是i-1左边的球移动到坐标i-1的操作数+从i-1移动到i的球需要的操作数

同理，再次从右遍历boxes，计算dp2，也就是右边的球移动到下标i需要的操作数。

最后的结果，即为2个dp数组的和


# 复杂度
- 时间复杂度: 
> $O(n)$ 

- 空间复杂度: 
> $O(n)$
'''


class Solution:

    def minOperations(self, boxes: str) -> List[int]:
        n = len(boxes)
        dp1, dp2 = [0] * n, [0] * n
        count = 1 if boxes[0] == '1' else 0  # count统计截止下标i之前小球的个数
        for i in range(1, n):
            dp1[i] = dp1[i - 1] + count  # 计算左边小球从i-1移动到i需要的操作数
            count += 1 if boxes[i] == '1' else 0
        count = 1 if boxes[-1] == '1' else 0
        for i in range(n - 2, -1, -1):
            dp2[i] = dp2[i + 1] + count  # 计算右边小球从i+1移动到i需要的操作数
            count += 1 if boxes[i] == '1' else 0
        return [dp1[i] + dp2[i] for i in range(n)]
