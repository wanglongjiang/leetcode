'''
数组中重复的数据

给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。

找到所有出现两次的元素。

你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？

示例：

输入:
[4,3,2,7,8,2,3,1]

输出:
[2,3]
'''
from typing import List
'''
思路：计数
因为数组中的元素1<=a[i]<=n，可以使用在原数组计数的方式。元素nums[i]应该放到nums[nums[i]-1]上面。
设2个特殊值，0和1，如果出现在数组中的含义是:
> 0代表该处元素被提走。如果从1个位置将数字a拿走，暂时没有其他该定位到该位置的元素存在，该位置设置为0
> -1代表该处元素已被设置。如果该位置被元素定位了，设置为-1。
例如：nums[3]的值是6，那么6应该放到nums[7]处，先从nums[3]将6提走，nums[3]设置为0，
> 然后拿着6到nums[7]，如果nums[7]是个正整数，需要将nums[7]提走，因为6已经来到了nums[7]将nums[7]设置为-1，再定位原nums[7]的值；
> 如果拿着6到了nums[7]，发现nums[7]是0，说明nums[7]之前已经被提走，还没有6过来占据这个位置，直接设为-1即可；
> 如果拿着6到了nums[7]，发现nums[7]是-1，说明有6之前已经到过该位置，6就是重复值。
通过遍历nums所有元素，将所有元素进行定位，定位过程按上面的描述进行。

时间复杂度：O(n)，每个位置的元素最多被提出、设置1次
空间复杂度：O(1)
'''


class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        ans = []
        for i in range(len(nums)):
            if nums[i] != 0 and nums[i] != -1:  # 只有正整数才是正常值，需要进行定位
                t = nums[i]
                nums[i] = 0
                while t != 0:  # 从t开始追踪所有的正常元素，链路追踪
                    if nums[t - 1] == 0:  # 该元素之前已被提走，将其设置为-1，表示已定位完成
                        nums[t - 1] = -1
                        t = 0
                    elif nums[t - 1] == -1:  # 该元素之前已经就位过一次，再次定位到该位置说明是重复元素
                        ans.append(t)
                        t = 0
                    else:  # 定位的位置上有其他元素，将位置定位后，再定位该位置上的元素
                        nt = nums[t - 1]
                        nums[t - 1] = -1
                        t = nt
        return ans


s = Solution()
print(s.findDuplicates([4, 3, 2, 7, 8, 2, 3, 1]))
