'''
1024. 视频拼接
你将会获得一系列视频片段，这些片段来自于一项持续时长为 T 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。

视频片段 clips[i] 都用区间进行表示：开始于 clips[i][0] 并于 clips[i][1] 结束。我们甚至可以对这些片段自由地再剪辑，
例如片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。

我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。返回所需片段的最小数目，
如果无法完成该任务，则返回 -1 。



示例 1：

输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10
输出：3
解释：
我们选中 [0,2], [8,10], [1,9] 这三个片段。
然后，按下面的方案重制比赛片段：
将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。
现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。
示例 2：

输入：clips = [[0,1],[1,2]], T = 5
输出：-1
解释：
我们无法只用 [0,1] 和 [1,2] 覆盖 [0,5] 的整个过程。
示例 3：

输入：clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9
输出：3
解释：
我们选取片段 [0,4], [4,7] 和 [6,9] 。
示例 4：

输入：clips = [[0,4],[2,8]], T = 5
输出：2
解释：
注意，你可能录制超过比赛结束时间的视频。


提示：

1 <= clips.length <= 100
0 <= clips[i][0] <= clips[i][1] <= 100
0 <= T <= 100
'''
from typing import List
'''
思路：动态规划
首先对时间区间按照从小到大进行排序。
然后对于clips[i]向前(向左0..i-1)搜索能跟当前时间段连结上的时间段，最小片段为能连结上的最小片段数+1。
设数组dp[n]，dp[i]的意思是从开始连结到第i个视频片段，最少需要的视频片段。
状态转移方程为：
dp[i] = min(dp[j])+1，j满足0<=j<i，且clips[j][1]>=clips[i][0]
初始化：
如果clips[i][0]<=0，则dp[i]=1

最终结果为min(dp[k])，k满足clips[k][1]>=time

时间复杂度：O($n^2$)，排序需要O(n$log^n$)，计算转移方程需要O($n^2$)
空间复杂度：O(n)
'''


class Solution:
    def videoStitching(self, clips: List[List[int]], time: int) -> int:
        clips.sort()  # 按开始时间排序
        n = len(clips)
        dp = [float('inf')] * n
        if clips[0][0] > 0:  # 第0个开始时间不为0
            return -1
        for i in range(n):
            if clips[i][0] == 0:
                dp[i] = 1
            else:
                for j in range(i - 1, -1, -1):  # 向前搜索能与当前视频连结的最小视频量
                    if clips[i][0] <= clips[j][1]:
                        dp[i] = min(dp[i], dp[j] + 1)
        ans = float('inf')
        for i in range(n - 1, -1, -1):  # 在结束时间大于time的视频片段里找需要的视频数最少的
            if clips[i][1] >= time:
                ans = min(ans, dp[i])
        return ans if ans <= n else -1


s = Solution()
print(s.videoStitching([[0, 2], [4, 6], [8, 10], [1, 9], [1, 5], [5, 9]], 10))
print(s.videoStitching([[0, 1], [1, 2]], 5))
print(s.videoStitching([[0, 1], [6, 8], [0, 2], [5, 6], [0, 4], [0, 3], [6, 7], [1, 3], [4, 7], [1, 4], [2, 5], [2, 6], [3, 4], [4, 5], [5, 7], [6, 9]], 9))
print(s.videoStitching([[0, 4], [2, 8]], 5))
