'''
K 站中转内最便宜的航班

有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] = [fromi, toi, pricei] ，表示该航班都从城市 fromi 开始，以价格 toi 抵达 pricei。

现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k 站中转的路线，使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。

 

示例 1：

输入:
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 1
输出: 200
解释:
城市航班图如下


从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。
示例 2：

输入:
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 0
输出: 500
解释:
城市航班图如下


从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。
 

提示：

1 <= n <= 100
0 <= flights.length <= (n * (n - 1) / 2)
flights[i].length == 3
0 <= fromi, toi < n
fromi != toi
1 <= pricei <= 10^4
航班没有重复，且不存在自环
0 <= src, dst, k < n
src != dst

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/cheapest-flights-within-k-stops
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
'''
from typing import List
'''
思路：BFS
从源点出发，用BFS遍历所有的路径，
注意2点：
1、需要记录到达每个节点的费用，如果一个节点被再次遍历到时，当价格降低了，需要把经过该节点的路径再次遍历一次，否则不需要再次遍历
2、需要记录中转的次数，当次数超过k时，不再加入队列遍历

时间复杂度：O(kn^2)
'''


class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        # 构造邻接表形式的图
        graph = [[] for _ in range(n)]
        for p in flights:
            graph[p[0]].append(p)
        # 从src出发进行BFS遍历
        q, nextq = [], []
        length = 0
        q.append((src, 0))
        ans = float('inf')
        priceMap = {}  # 用于记录到达某个节点的价格
        while q:
            node, price = q.pop()
            if node == dst:
                ans = min(ans, price)
            elif node not in priceMap or priceMap[node] > price:  # 只有该路径没遍历过，或者比之前的价格便宜的时候才需要遍历后面的节点
                priceMap[node] = price
                if length <= k:  # 中转超过k次不遍历后面的节点
                    for nextLine in graph[node]:
                        nextq.append((nextLine[1], nextLine[2] + price))
            if not q:
                q, nextq = nextq, q
                length += 1
        return ans if ans != float('inf') else -1


s = Solution()
print(s.findCheapestPrice(n=3, flights=[[0, 1, 100], [1, 2, 100], [0, 2, 500]], src=0, dst=2, k=0))
print(s.findCheapestPrice(n=3, flights=[[0, 1, 100], [1, 2, 100], [0, 2, 500]], src=0, dst=2, k=1))
print(
    s.findCheapestPrice(
        18, [[16, 1, 81], [15, 13, 47], [1, 0, 24], [5, 10, 21], [7, 1, 72], [0, 4, 88], [16, 4, 39], [9, 3, 25], [10, 11, 28], [13, 8, 93], [10, 3, 62],
             [14, 0, 38], [3, 10, 58], [3, 12, 46], [3, 8, 2], [10, 16, 27], [6, 9, 90], [14, 8, 6], [0, 13, 31], [6, 4, 65], [14, 17, 29], [13, 17, 64],
             [12, 5, 26], [12, 1, 9], [12, 15, 79], [16, 11, 79], [16, 15, 17], [4, 0, 21], [15, 10, 75], [3, 17, 23], [8, 5, 55], [9, 4, 19], [0, 10, 83],
             [3, 7, 17], [0, 12, 31], [11, 5, 34], [17, 14, 98], [11, 14, 85], [16, 7, 48], [12, 6, 86], [5, 17, 72], [4, 12, 5], [12, 10, 23], [3, 2, 31],
             [12, 7, 5], [6, 13, 30], [6, 7, 88], [2, 17, 88], [6, 8, 98], [0, 7, 69], [10, 15, 13], [16, 14, 24], [1, 17, 24], [13, 9, 82], [13, 6, 67],
             [15, 11, 72], [12, 0, 83], [1, 4, 37], [12, 9, 36], [9, 17, 81], [9, 15, 62], [8, 15, 71], [10, 12, 25], [7, 6, 23], [16, 5, 76], [7, 17, 4],
             [3, 11, 82], [2, 11, 71], [8, 4, 11], [14, 10, 51], [8, 10, 51], [4, 1, 57], [6, 16, 68], [3, 9, 100], [1, 14, 26], [10, 7, 14], [8, 17, 24],
             [1, 11, 10], [2, 9, 85], [9, 6, 49], [11, 4, 95]], 7, 2, 6))
