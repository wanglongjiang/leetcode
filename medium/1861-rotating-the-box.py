'''
旋转盒子
给你一个 m x n 的字符矩阵 box ，它表示一个箱子的侧视图。箱子的每一个格子可能为：

'#' 表示石头
'*' 表示固定的障碍物
'.' 表示空位置
这个箱子被 顺时针旋转 90 度 ，由于重力原因，部分石头的位置会发生改变。每个石头会垂直掉落，
直到它遇到障碍物，另一个石头或者箱子的底部。重力 不会 影响障碍物的位置，同时箱子旋转不会产生惯性 ，也就是说石头的水平位置不会发生改变。

题目保证初始时 box 中的石头要么在一个障碍物上，要么在另一个石头上，要么在箱子的底部。

请你返回一个 n x m的矩阵，表示按照上述旋转后，箱子内的结果。

 

示例 1：



输入：box = [["#",".","#"]]
输出：[["."],
      ["#"],
      ["#"]]
示例 2：



输入：box = [["#",".","*","."],
            ["#","#","*","."]]
输出：[["#","."],
      ["#","#"],
      ["*","*"],
      [".","."]]
示例 3：



输入：box = [["#","#","*",".","*","."],
            ["#","#","#","*",".","."],
            ["#","#","#",".","#","."]]
输出：[[".","#","#"],
      [".","#","#"],
      ["#","#","*"],
      ["#","*","."],
      ["#",".","*"],
      ["#",".","."]]
 

提示：

m == box.length
n == box[i].length
1 <= m, n <= 500
box[i][j] 只可能是 '#' ，'*' 或者 '.' 。
'''
from typing import List
'''
思路：双指针移动+矩阵转置
1. 首先将箱子视为受到向右的重力，将箱子从低左部移动到高坐标。
> 这里设置快慢指针left,right，left从右向左搜索遇到第1个空位置，将right指向这里，然后left继续向左移动
> left指针移动的过程中，如果遇到了障碍，right指针跳到跟left指针相同位置。
> 移动left直至遇到箱子，left指向的箱子移动到right。然后right指针向右移动至下一个空位，right指针不能超过left。
2. 建立一个向右旋转90度的新矩阵，将旧矩阵里面的内容复制过去
> 旧矩阵到新矩阵的坐标转化公式为i,j = j,m-i

时间复杂度：O(m*n)
空间复杂度：O(1)，除了返回值，没有占用其他空间
'''


class Solution:
    def rotateTheBox(self, box: List[List[str]]) -> List[List[str]]:
        m, n = len(box), len(box[0])
        # 1.双指针向右移动箱子到空位
        for i in range(m - 1, -1, -1):
            left, right = n - 1, n - 1
            while right >= 0:
                while right >= 0 and (box[i][right] == '*' or box[i][right] == '#'):  # 跳过所有的石头和障碍，找到空位
                    right -= 1
                if right >= 0 and box[i][right] == '.':
                    left = right - 1
                    while left >= 0 and box[i][left] == '.':  # 跳过所有的空位，直到遇到障碍或箱子
                        left -= 1
                    if left >= 0:
                        if box[i][left] == '#':  # 如果遇到了箱子，移动箱子
                            box[i][left] = '.'
                            box[i][right] = '#'
                        else:  # 如果遇到了障碍，right指针从障碍的下一个位置继续查找空位
                            right = left - 1
                    else:  # 未找到箱子，退出
                        break
        # 2. 将旧矩阵内容复制到新矩阵
        ans = [[None] * m for _ in range(n)]
        for i in range(m):
            for j in range(n):
                ans[j][m - i - 1] = box[i][j]
        return ans


s = Solution()
print(s.rotateTheBox([["#", ".", "#"]]))
print(s.rotateTheBox([["#", ".", "*", "."], ["#", "#", "*", "."]]))
print(s.rotateTheBox([["#", "#", "*", ".", "*", "."], ["#", "#", "#", "*", ".", "."], ["#", "#", "#", ".", "#", "."]]))
