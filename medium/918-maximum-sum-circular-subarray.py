'''
环形子数组的最大和
给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。

在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当0 <= i < A.length 时 C[i] = A[i]，且当 i >= 0 时 C[i+A.length] = C[i]）

此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。（形式上，对于子数组 C[i], C[i+1], ..., C[j]，不存在 i <= k1, k2 <= j 其中 k1 % A.length = k2 % A.length）

 

示例 1：

输入：[1,-2,3,-2]
输出：3
解释：从子数组 [3] 得到最大和 3
示例 2：

输入：[5,-3,5]
输出：10
解释：从子数组 [5,5] 得到最大和 5 + 5 = 10
示例 3：

输入：[3,-1,2,-1]
输出：4
解释：从子数组 [2,-1,3] 得到最大和 2 + (-1) + 3 = 4
示例 4：

输入：[3,-2,2,-3]
输出：3
解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3
示例 5：

输入：[-2,-3,-1]
输出：-1
解释：从子数组 [-1] 得到最大和 -1
 

提示：

-30000 <= A[i] <= 30000
1 <= A.length <= 30000
'''
from typing import List
'''
思路：动态规划
该题目是 - 53.[最大子序和](easy/53-maximum-subarray.py)的升级，算法名字叫kadane
最大子数组和=max(未跨越末尾元素的子数组和，跨越末尾元素的子数组和)
未跨越末尾元素的子数组和=53的常规算法
跨越末尾元素的子数组和=整个数组和-最小的序列和
最小的序列和= kadane(-nums)

时间复杂度：O(n)
空间复杂度：O(n)
'''


class Solution:
    def maxSubarraySumCircular(self, nums: List[int]) -> int:
        maxItem = max(nums)
        if maxItem < 0:
            return maxItem

        def kadane(nums):
            result = cur = float('-inf')
            for num in nums:
                cur = max(cur, 0) + num
                result = max(result, cur)
            return result

        return max(sum(nums) + kadane([-num for num in nums]), kadane(nums))


s = Solution()
print(s.maxSubarraySumCircular([1, -2, 3, -2]))
print(s.maxSubarraySumCircular([5, -3, 5]))
print(s.maxSubarraySumCircular([3, -1, 2, -1]))
print(s.maxSubarraySumCircular([3, -2, 2, -3]))
print(s.maxSubarraySumCircular([-2, -3, -1]))
print(
    s.maxSubarraySumCircular([
        52, 183, 124, 154, -170, -191, -240, 107, -178, 171, 75, 186, -125, 61, -298, 284, 21, -73, -294, 253, 146, 248, -248, 127, 26, 289, 118, -22, -300, 26,
        -116, -113, -44, 29, 252, -278, 47, 254, -106, 246, -275, 42, 257, 15, 96, -298, -69, -104, -239, -95, -4, 76, -202, 156, -14, -178, 188, -84, 78, -195,
        -125, 28, 109, 125, -25, -53, 58, 287, 55, -296, 198, 281, 53, -160, 146, 298, 25, -41, -3, 27, -242, 169, 287, -281, 19, 91, 213, 115, 211, -218, 124,
        -25, -272, 278, 296, -177, -166, -192, 97, -49, -25, 168, -81, 6, -94, 267, 293, 146, -1, -258, 256, 283, -156, 197, 28, 78, 267, -151, -230, -66, 100,
        -94, -66, -123, 121, -214, -182, 187, 65, -186, 215, 273, 243, -99, -76, 178, 59, 190, 279, 300, 217, 67, -117, 170, 163, 153, -37, -147, -251, 296,
        -176, 117, 68, 258, -159, -300, -36, -91, -60, 195, -293, -116, 208, 175, -100, -97, 188, 79, -270, 80, 100, 211, 112, 264, -217, -142, 5, 105, 171,
        -264, -247, 138, 275, 227, -86, 30, -219, 153, 10, -66, 267, 22, -56, -70, -234, -66, 89, 182, 110, -146, 162, -48, -201, -240, -225, -15, -275, 129,
        -117, 28, 150, 84, -264, 249, -85, 70, -140, -259, 26, 162, 5, -203, 143, 184, 101, 140, 207, 131, 177, 274, -178, -79, 14, -36, 104, 52, 31, 257, 273,
        -52, 74, 276, 104, -133, -255, 188, -252, 229, 200, -74, -39, -250, 142, -201, -196, -43, -40, 255, -149, -299, -197, -175, -96, -155, -196, -24, 12,
        79, 71, -144, -59, -120, 227, -256, -163, -297, 116, 286, -283, -31, -221, -41, 121, -170, 160, 205, 8, 88, 25, -272, -107, 292, -180, 299, 94, -97,
        -81, -134, 37, 238
    ]) == 5803)
print(s.maxSubarraySumCircular([0, 5, 8, -9, 9, -7, 3, -2]))
print(s.maxSubarraySumCircular([-2]))
