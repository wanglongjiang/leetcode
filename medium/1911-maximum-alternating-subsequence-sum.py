'''
1911. 最大子序列交替和
一个下标从 0 开始的数组的 交替和 定义为 偶数 下标处元素之 和 减去 奇数 下标处元素之 和 。

比方说，数组 [4,2,5,3] 的交替和为 (4 + 5) - (2 + 3) = 4 。
给你一个数组 nums ，请你返回 nums 中任意子序列的 最大交替和 （子序列的下标 重新 从 0 开始编号）。

一个数组的 子序列 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。
比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的一个子序列（加粗元素），但是 [2,4,2] 不是。

 

示例 1：

输入：nums = [4,2,5,3]
输出：7
解释：最优子序列为 [4,2,5] ，交替和为 (4 + 5) - 2 = 7 。
示例 2：

输入：nums = [5,6,7,8]
输出：8
解释：最优子序列为 [8] ，交替和为 8 。
示例 3：

输入：nums = [6,2,1,2,4,5]
输出：10
解释：最优子序列为 [6,1,5] ，交替和为 (6 + 5) - 1 = 10 。
 

提示：

1 <= nums.length <= 105
1 <= nums[i] <= 105
'''
from typing import List
'''
思路：贪心
当出现递减子数组时，序列只需要保留子数组的2端，中间的元素都删掉，子数组第1个元素减掉最后一个元素，得到的结果值能够最大化
当出现递增子数组时，因为递增子数组得到的任何序列结果都小于0，所以只保留子数组最后一个元素

时间复杂度：O(n)
空间复杂度：O(1)
'''


class Solution:
    def maxAlternatingSum(self, nums: List[int]) -> int:
        pre, starti, endi, ans = 0, 0, 0, 0  # 4个变量分别保存前一元素，递减子数组开始坐标，结束坐标，最终结果
        for i, num in enumerate(nums):
            if num > pre:
                if endi > starti:  # 出现了递增，将上一个递减的子序列和累计入答案
                    ans += nums[starti] - nums[endi]
                starti = i  # 递减子数组的起始下标重新开始计数
            pre = num
            endi = i  # 扩大递减子数组的大小
        ans += nums[starti]  # 最后一个序列可以只保留开始元素，这样得到的和最大
        return ans


s = Solution()
print(s.maxAlternatingSum([4, 2, 5, 3]))
print(s.maxAlternatingSum([5, 6, 7, 8]))
print(s.maxAlternatingSum([6, 2, 1, 2, 4, 5]))
