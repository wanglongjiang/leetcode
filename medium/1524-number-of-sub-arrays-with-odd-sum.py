'''
1524. 和为奇数的子数组数目
给你一个整数数组 arr 。请你返回和为 奇数 的子数组数目。

由于答案可能会很大，请你将结果对 10^9 + 7 取余后返回。

 

示例 1：

输入：arr = [1,3,5]
输出：4
解释：所有的子数组为 [[1],[1,3],[1,3,5],[3],[3,5],[5]] 。
所有子数组的和为 [1,4,9,3,8,5].
奇数和包括 [1,9,3,5] ，所以答案为 4 。
示例 2 ：

输入：arr = [2,4,6]
输出：0
解释：所有子数组为 [[2],[2,4],[2,4,6],[4],[4,6],[6]] 。
所有子数组和为 [2,6,12,4,10,6] 。
所有子数组和都是偶数，所以答案为 0 。
示例 3：

输入：arr = [1,2,3,4,5,6,7]
输出：16
示例 4：

输入：arr = [100,100,99,99]
输出：4
示例 5：

输入：arr = [7]
输出：1
 

提示：

1 <= arr.length <= 10^5
1 <= arr[i] <= 100
'''
from typing import List
'''
思路：前缀和
设1个变量，保存截止当前坐标的前缀和是奇数还是偶数
设2个变量，分别保存截止当前元素的偶数前缀和个数和奇数前缀和个数

遍历所有元素：
- 如果当前元素如果前缀和是奇数，可以与前面所有偶数前缀和下标构成和为奇数的子数组；
- 如果前缀和是偶数，可以与前面所有奇数前缀和下标构成子数组。

时间复杂度：O(n)
空间复杂度：O(1)
'''


class Solution:
    def numOfSubarrays(self, arr: List[int]) -> int:
        evenCnt, oddCnt = 1, 0  # 偶数、奇数前缀和初始个数
        preSum = 0  # 上一个坐标的前缀和奇偶性，初始为0
        ans, m = 0, 10**9 + 7
        for num in arr:
            preSum ^= num & 1  # 偶数+偶数，奇数+奇数为偶数；偶+奇 or 奇+偶 为奇数
            if preSum:
                oddCnt += 1
                ans += evenCnt  # 当前坐标前缀和为奇数，可以与前面所有的前缀和为偶数的坐标构成需要的子数组
            else:
                evenCnt += 1
                ans += oddCnt  # 当前坐标前缀和为偶数，可以与前面所有的前缀和为奇数的坐标构成需要的子数组
        return ans % m


s = Solution()
assert s.numOfSubarrays([1, 3, 5]) == 4
assert s.numOfSubarrays([100, 100, 99, 99]) == 4
assert s.numOfSubarrays([7]) == 1
