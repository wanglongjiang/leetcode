'''
790. 多米诺和托米诺平铺
有两种形状的瓷砖：一种是 2 x 1 的多米诺形，另一种是形如 "L" 的托米诺形。两种形状都可以旋转。



给定整数 n ，返回可以平铺 2 x n 的面板的方法的数量。返回对 109 + 7 取模 的值。

平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，
使得恰好有一个平铺有一个瓷砖占据两个正方形。

 

示例 1:



输入: n = 3
输出: 5
解释: 五种不同的方法如上所示。
示例 2:

输入: n = 1
输出: 1
 

提示：

1 <= n <= 1000
'''
'''
思路：动态规划
每列都有四种不同的铺砖状态，且每种状态都可以在前一列和当前列已存在的不同铺砖状态下，通过再次铺砖转换得到。

分析四种不同的铺砖状态可在哪些状态下转换得到。

两行都不铺

两列都未铺，然后在第一行垂直铺多米诺瓷砖
第一列已铺，第二列未铺，且不铺砖
第一行不铺，第二行铺

两列都未铺，然后铺多米诺瓷砖
第一列第一行已铺，然后在第一列第二行水平铺多米诺瓷砖
第一行铺，第二行不铺 ---- 与第一行不铺，第二行铺的方法对称

两行都铺

两列都未铺，然后水平铺两个多米诺瓷砖
第一列有一行已铺，然后铺一个托米诺瓷砖（实际上是两种情况）


时间复杂度：O(n)
空间复杂度：O(1)
'''


class Solution:
    def numTilings(self, n: int) -> int:
        m = 10**9 + 7
        dp = [1, 0, 0, 0]
        for _ in range(n):
            ndp = [0, 0, 0, 0]
            ndp[0b00] = (dp[0b00] + dp[0b11]) % m
            ndp[0b01] = (dp[0b00] + dp[0b10]) % m
            ndp[0b10] = (dp[0b00] + dp[0b01]) % m
            ndp[0b11] = (dp[0b00] + dp[0b01] + dp[0b10]) % m
            dp = ndp
        return dp[0]


s = Solution()
assert s.numTilings(3) == 5
assert s.numTilings(1) == 1
assert s.numTilings(4) == 11
